3️⃣ Add the JS logic for these controls

In your <script> (at the bottom of template.html), make sure you have your canvas, selectedZoneObject, etc. defined.

Now add (or replace) the following pieces.

3.1 Globals for snapping

Near the top of your script:

let SNAP_ENABLED = true;
const GRID_SIZE = 10; // px grid size


And wire the checkbox (put this after the DOM has loaded, e.g. at the end of the script):

document.getElementById('snapToggle').addEventListener('change', (e) => {
    SNAP_ENABLED = e.target.checked;
});

3.2 Snapping on move + resize

Add these listeners (once):

canvas.on('object:moving', function (e) {
    if (!SNAP_ENABLED) return;
    const obj = e.target;
    obj.left = Math.round(obj.left / GRID_SIZE) * GRID_SIZE;
    obj.top = Math.round(obj.top / GRID_SIZE) * GRID_SIZE;
});

canvas.on('object:scaling', function (e) {
    if (!SNAP_ENABLED) return;
    const obj = e.target;
    const w = obj.width * obj.scaleX;
    const h = obj.height * obj.scaleY;
    obj.scaleX = Math.round(w / GRID_SIZE) * GRID_SIZE / obj.width;
    obj.scaleY = Math.round(h / GRID_SIZE) * GRID_SIZE / obj.height;
});

3.3 Enable/disable all zone buttons correctly

Update your enableZoneActions() and disableZoneActions() to include the new buttons:

function disableZoneActions() {
    const ids = [
        'btnAssignPlaylist',
        'btnAssignRSS',
        'btnAssignSocial',
        'btnAssignTicker',
        'btnDeleteZone',
        'btnDuplicateZone',
        'btnLockZone',
        'btnUnlockZone'
    ];
    ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = true;
    });
}

function enableZoneActions() {
    const ids = [
        'btnAssignPlaylist',
        'btnAssignRSS',
        'btnAssignSocial',
        'btnAssignTicker',
        'btnDeleteZone',
        'btnDuplicateZone',
        'btnLockZone',
        'btnUnlockZone'
    ];
    ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = false;
    });
}


Your updateZonePanel(obj) should already call these; if not, make sure it does:

function updateZonePanel(obj) {
    if (!obj || !obj.zone) {
        document.getElementById("selectedZoneName").innerText = "None";
        disableZoneActions();
        return;
    }

    document.getElementById("selectedZoneName").innerText = obj.zone.name;
    enableZoneActions();
}

3.4 Duplicate, lock, unlock, delete

Add these functions:

function duplicateZone() {
    const obj = canvas.getActiveObject();
    if (!obj || !obj.zone) return;

    obj.clone(function (clone) {
        clone.set({
            left: obj.left + 20,
            top: obj.top + 20
        });

        clone.zone = {
            ...obj.zone,
            id: 'zone-' + Date.now(),
            name: obj.zone.name + ' Copy'
        };

        canvas.add(clone);
        canvas.setActiveObject(clone);
        updateZonePanel(clone);
        canvas.renderAll();
    });
}

function lockZone() {
    const obj = canvas.getActiveObject();
    if (!obj) return;
    obj.lockMovementX = true;
    obj.lockMovementY = true;
    obj.lockScalingX = true;
    obj.lockScalingY = true;
    obj.lockRotation = true;
    obj.hasControls = false;
    canvas.renderAll();
}

function unlockZone() {
    const obj = canvas.getActiveObject();
    if (!obj) return;
    obj.lockMovementX = false;
    obj.lockMovementY = false;
    obj.lockScalingX = false;
    obj.lockScalingY = false;
    obj.lockRotation = false;
    obj.hasControls = true;
    canvas.renderAll();
}

function deleteZone() {
    if (!selectedZoneObject) return;
    canvas.remove(selectedZoneObject);
    selectedZoneObject = null;
    updateZonePanel(null);
    canvas.renderAll();
}

3.5 Corner radius & rotation controls

Assuming each zone group’s first child is the rectangle:

function getActiveRect() {
    const obj = canvas.getActiveObject();
    if (!obj || !obj._objects || !obj._objects[0]) return null;
    return obj._objects[0];
}

function onCornerRadiusChange(val) {
    const rect = getActiveRect();
    if (!rect) return;
    const r = parseInt(val, 10) || 0;
    rect.rx = r;
    rect.ry = r;
    canvas.renderAll();
}

function onRotationChange(val) {
    const obj = canvas.getActiveObject();
    if (!obj) return;
    obj.angle = parseInt(val, 10) || 0;
    canvas.renderAll();
}


You can optionally reset the slider when selecting a new zone by reading its current angle etc., but this is enough to start.

3.6 Background image upload
function setBackgroundImage(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (evt) {
        fabric.Image.fromURL(evt.target.result, function (img) {
            img.scaleToWidth(canvas.width);
            canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
        });
    };
    reader.readAsDataURL(file);
}

3.7 Export / import templates

Re-use your existing extractZonesFromCanvas() to export:

function exportTemplate() {
    const zones = extractZonesFromCanvas();
    const data = JSON.stringify(zones, null, 2);

    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'template-zones.json';
    a.click();

    URL.revokeObjectURL(url);
}


Import:

function importTemplate(e) {
    const file = e.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (evt) {
        try {
            const zones = JSON.parse(evt.target.result);
            canvas.clear();
            canvas.setBackgroundColor('#000000', canvas.renderAll.bind(canvas));

            zones.forEach(z => {
                loadZoneFromJson(z);
            });
        } catch (err) {
            alert('Invalid template JSON');
        }
    };
    reader.readAsText(file);
}

function loadZoneFromJson(z) {
    const rect = new fabric.Rect({
        left: (z.x / 100) * canvas.width,
        top: (z.y / 100) * canvas.height,
        width: (z.width / 100) * canvas.width,
        height: (z.height / 100) * canvas.height,
        fill: "rgba(74,124,89,0.15)",
        stroke: "#4a7c59",
        strokeWidth: 2
    });

    const label = new fabric.Text(z.name, {
        left: rect.left + 10,
        top: rect.top + 10,
        fontSize: 14,
        fill: "white"
    });

    const group = new fabric.Group([rect, label], {
        left: rect.left,
        top: rect.top,
        hasRotatingPoint: false
    });

    group.zone = { ...z };

    canvas.add(group);
}