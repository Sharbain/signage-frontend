// server.js
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');
const path = require('path');
const multer = require('multer');
const fs = require('fs');
const cron = require('node-cron');

const app = express();
const PORT = process.env.PORT || 5000;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
const BASE_URL = process.env.BASE_URL || ''; // optional, for building full media URLs

// Database connection
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Ensure uploads folder exists
if (!fs.existsSync(path.join(__dirname, 'uploads'))) {
  fs.mkdirSync(path.join(__dirname, 'uploads'));
}

// Multer setup for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  filename: function (req, file, cb) {
    const unique = Date.now() + '-' + Math.round(Math.random() * 1e9);
    cb(null, `${unique}-${file.originalname}`);
  }
});
const upload = multer({ storage });

// ---------- Helper middleware ----------
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  if (!authHeader) return res.status(401).json({ error: 'Missing auth header' });
  const token = authHeader.split(' ')[1];
  if (!token) return res.status(401).json({ error: 'Missing token' });

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.status(401).json({ error: 'Invalid token' });
    req.user = user;
    next();
  });
}

function requireRole(role) {
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ error: 'Not authenticated' });
    if (req.user.role !== role && req.user.role !== 'admin') {
      return res.status(403).json({ error: 'Forbidden' });
    }
    next();
  };
}

// ---------- Serve HTML pages ----------
app.get('/display.html', (req, res) => res.sendFile(path.join(__dirname, 'display.html')));
app.get('/api-test.html', (req, res) => res.sendFile(path.join(__dirname, 'api-test.html')));
app.get('/', (req, res) => res.sendFile(path.join(__dirname, 'index.html')));

// ---------- AUTH ROUTES ----------
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, role = 'restricted' } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await pool.query(
      'INSERT INTO users (email, password_hash, role) VALUES ($1, $2, $3) RETURNING id, email, role',
      [email, hashedPassword, role]
    );
    res.json({ message: 'User registered', user: result.rows[0] });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    const user = result.rows[0];
    if (!user || !(await bcrypt.compare(password, user.password_hash))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const accessToken = jwt.sign({ sub: user.id, email: user.email, role: user.role }, JWT_SECRET, { expiresIn: '24h' });
    res.json({ accessToken, user: { id: user.id, email: user.email, role: user.role } });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// ---------- SCREENS (DEVICES) ----------
app.post('/api/screens/register', async (req, res) => {
  // Device self-registers with deviceId and metadata
  try {
    const { deviceId, name, resolution, location, simIccid } = req.body;
    const result = await pool.query(
      `INSERT INTO screens (device_id, name, resolution, location, sim_iccid, status)
       VALUES ($1,$2,$3,$4,$5,$6)
       ON CONFLICT (device_id) DO UPDATE
         SET name = EXCLUDED.name, resolution = EXCLUDED.resolution, location = EXCLUDED.location, sim_iccid = EXCLUDED.sim_iccid
       RETURNING *`,
      [deviceId, name || null, resolution || null, location || null, simIccid || null, 'offline']
    );
    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Register failed' });
  }
});

app.get('/api/screens', authenticateToken, requireRole('restricted'), async (req, res) => {
  const result = await pool.query('SELECT * FROM screens ORDER BY id');
  res.json(result.rows);
});

app.patch('/api/screens/:id', authenticateToken, requireRole('restricted'), async (req, res) => {
  const { id } = req.params;
  const { name, location, status, resolution } = req.body;
  const result = await pool.query(
    'UPDATE screens SET name = COALESCE($1, name), location = COALESCE($2, location), status = COALESCE($3, status), resolution = COALESCE($4, resolution) WHERE id = $5 RETURNING *',
    [name, location, status, resolution, id]
  );
  res.json(result.rows[0]);
});

app.delete('/api/screens/:id', authenticateToken, requireRole('admin'), async (req, res) => {
  await pool.query('DELETE FROM screens WHERE id = $1', [req.params.id]);
  res.json({ message: 'Screen deleted' });
});

// ---------- HEARTBEAT (Device pings frequently) ----------
app.post('/api/screens/:deviceId/heartbeat', async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { status = 'online', battery, ip, bandwidth_used = 0, uptime_seconds = 0, lat = null, lon = null, version = null } = req.body;
    const now = new Date();

    // upsert screen row if not exists
    await pool.query(
      `INSERT INTO screens (device_id, name, status, last_seen, location, latitude, longitude, platform_version)
       VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
       ON CONFLICT (device_id)
       DO UPDATE SET status = EXCLUDED.status, last_seen = EXCLUDED.last_seen, latitude = EXCLUDED.latitude, longitude = EXCLUDED.longitude, platform_version = EXCLUDED.platform_version`,
      [deviceId, deviceId, status, now, null, lat, lon, version]
    );

    // insert heartbeat record
    await pool.query(
      `INSERT INTO heartbeats (device_id, seen_at, status, ip, battery, bandwidth_used, uptime_seconds)
       VALUES ($1,$2,$3,$4,$5,$6,$7)`,
      [deviceId, now, status, ip || null, battery || null, bandwidth_used, uptime_seconds]
    );

    // update bandwidth usage accumulator
    await pool.query(
      `INSERT INTO device_bandwidth (device_id, day, bytes)
       VALUES ($1, CURRENT_DATE, $2)
       ON CONFLICT (device_id, day) DO UPDATE SET bytes = device_bandwidth.bytes + EXCLUDED.bytes`,
      [deviceId, bandwidth_used]
    );

    res.json({ message: 'Heartbeat recorded', last_seen: now });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Heartbeat failed' });
  }
});

// ---------- MEDIA UPLOADS ----------
app.post('/api/media/upload', authenticateToken, requireRole('restricted'), upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    if (!file) return res.status(400).json({ error: 'No file uploaded' });

    const url = `${BASE_URL || ''}/uploads/${file.filename}`;
    const { name = file.originalname, type = file.mimetype.startsWith('video') ? 'video' : 'image', duration = null } = req.body;

    const result = await pool.query(
      `INSERT INTO media (name, type, url, size, duration, uploaded_by)
       VALUES ($1,$2,$3,$4,$5,$6) RETURNING *`,
      [name, type, url, file.size, duration ? parseInt(duration) : null, req.user ? req.user.sub : null]
    );

    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Upload failed' });
  }
});

// Create media metadata entry (alternate method for remote URLs)
app.post('/api/media', authenticateToken, requireRole('restricted'), async (req, res) => {
  const { name, type, url, size, duration } = req.body;
  const result = await pool.query(
    'INSERT INTO media (name, type, url, size, duration) VALUES ($1,$2,$3,$4,$5) RETURNING *',
    [name, type, url, size || null, duration || null]
  );
  res.status(201).json(result.rows[0]);
});

app.get('/api/media', authenticateToken, requireRole('restricted'), async (req, res) => {
  const result = await pool.query('SELECT * FROM media ORDER BY id DESC');
  res.json(result.rows);
});

app.delete('/api/media/:id', authenticateToken, requireRole('admin'), async (req, res) => {
  const id = req.params.id;
  // fetch url to remove file from disk optionally
  const r = await pool.query('SELECT url FROM media WHERE id=$1', [id]);
  if (r.rows[0] && r.rows[0].url && r.rows[0].url.startsWith('/uploads')) {
    const filename = r.rows[0].url.split('/').pop();
    const filepath = path.join(__dirname, 'uploads', filename);
    if (fs.existsSync(filepath)) fs.unlinkSync(filepath);
  }
  await pool.query('DELETE FROM media WHERE id = $1', [id]);
  res.json({ message: 'Media deleted' });
});

// ---------- PLAYLIST / CONTENT ASSIGNMENT ----------
app.post('/api/playlists', authenticateToken, requireRole('restricted'), async (req, res) => {
  // Create a playlist (template) and assign media items
  const { name, items = [] } = req.body; // items = [{media_id, duration, order}]
  try {
    const p = await pool.query('INSERT INTO playlists (name, created_by) VALUES ($1,$2) RETURNING *', [name, req.user.sub]);
    const playlistId = p.rows[0].id;
    for (const it of items) {
      await pool.query('INSERT INTO playlist_items (playlist_id, media_id, item_order, duration) VALUES ($1,$2,$3,$4)', [playlistId, it.media_id, it.order || 0, it.duration || null]);
    }
    res.status(201).json({ playlistId });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Create playlist failed' });
  }
});

app.post('/api/assignments', authenticateToken, requireRole('restricted'), async (req, res) => {
  // Assign playlist to a screen with optional schedule window
  try {
    const { screen_id, playlist_id, start_at = null, end_at = null, repeat = true } = req.body;
    const r = await pool.query('INSERT INTO screen_assignments (screen_id, playlist_id, start_at, end_at, repeat_flag) VALUES ($1,$2,$3,$4,$5) RETURNING *',
      [screen_id, playlist_id, start_at, end_at, repeat]);
    res.status(201).json(r.rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Assignment failed' });
  }
});

// GET playlist for a specific device (what Android will call)
app.get('/api/screens/:deviceId/playlist', async (req, res) => {
  try {
    const { deviceId } = req.params;
    // Find screen id
    const screenRow = await pool.query('SELECT * FROM screens WHERE device_id = $1', [deviceId]);
    if (!screenRow.rows[0]) return res.status(404).json({ error: 'Screen not found' });
    const screenId = screenRow.rows[0].id;

    // Find active assignment(s) for this screen
    const now = new Date().toISOString();
    const assignments = await pool.query(
      `SELECT sa.* FROM screen_assignments sa
       WHERE sa.screen_id = $1
       AND (sa.start_at IS NULL OR sa.start_at <= $2)
       AND (sa.end_at IS NULL OR sa.end_at >= $2)
       ORDER BY sa.id DESC`,
      [screenId, now]
    );

    let playlistItems = [];
    if (assignments.rows.length > 0) {
      // take the most recent assignment(s)
      const playlistIds = assignments.rows.map(r => r.playlist_id);
      const items = await pool.query(
        `SELECT pi.*, m.url, m.type, m.name FROM playlist_items pi
         JOIN media m ON m.id = pi.media_id
         WHERE pi.playlist_id = ANY($1::int[])
         ORDER BY pi.playlist_id, pi.item_order`, [playlistIds]
      );
      playlistItems = items.rows.map(it => ({
        type: it.type,
        url: it.url,
        duration: it.duration || it.item_duration || 10000,
        name: it.name,
      }));
    } else {
      // fallback to default media list
      const fallback = await pool.query('SELECT id, name, type, url, duration FROM media ORDER BY id LIMIT 20');
      playlistItems = fallback.rows.map(r => ({ type: r.type, url: r.url, duration: r.duration || 10000, name: r.name }));
    }

    res.json({ deviceId, playlist: playlistItems });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch playlist' });
  }
});

// ---------- EMERGENCY BROADCAST ----------
app.post('/api/emergency', authenticateToken, requireRole('admin'), async (req, res) => {
  // Push emergency message (override) â€” devices should check /api/screens/:deviceId/override
  try {
    const { message, start_at = new Date().toISOString(), end_at = null } = req.body;
    const r = await pool.query('INSERT INTO emergencies (message, start_at, end_at, created_by) VALUES ($1,$2,$3,$4) RETURNING *',
      [message, start_at, end_at, req.user.sub]);
    res.status(201).json(r.rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Emergency creation failed' });
  }
});

app.get('/api/screens/:deviceId/override', async (req, res) => {
  // Called by device frequently to check if there's an active emergency override
  try {
    const { deviceId } = req.params;
    const now = new Date().toISOString();
    const r = await pool.query('SELECT * FROM emergencies WHERE start_at <= $1 AND (end_at IS NULL OR end_at >= $1) ORDER BY id DESC LIMIT 1', [now]);
    if (r.rows.length === 0) return res.json({ override: null });
    res.json({ override: r.rows[0] });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Override check failed' });
  }
});

// ---------- REPORTS / DOWNTIME ----------
app.get('/api/reports/downtime/:deviceId/:year/:month', authenticateToken, requireRole('restricted'), async (req, res) => {
  // Returns downtime percentage for the month (simple approach using heartbeat presence)
  try {
    const { deviceId, year, month } = req.params;
    const start = new Date(`${year}-${month}-01T00:00:00Z`);
    const end = new Date(start);
    end.setMonth(end.getMonth() + 1);

    // count number of minutes with a heartbeat present (approx)
    const q = await pool.query(
      `SELECT COUNT(*) as heartbeats FROM heartbeats WHERE device_id=$1 AND seen_at >= $2 AND seen_at < $3`,
      [deviceId, start.toISOString(), end.toISOString()]
    );
    const hbCount = parseInt(q.rows[0].heartbeats, 10);

    // assume we expect heartbeat every 5 minutes -> expected points:
    const minutesInMonth = Math.round((end - start) / (1000 * 60));
    const expectedCount = Math.ceil(minutesInMonth / 5);
    const uptimePct = Math.min(100, Math.round(100 * hbCount / expectedCount));
    const downtimePct = 100 - uptimePct;

    res.json({ deviceId, month: `${year}-${month}`, uptimePct, downtimePct, heartbeats: hbCount, expectedCount });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Report failed' });
  }
});

// ---------- BANDWIDTH per day endpoint ----------
app.get('/api/bandwidth/:deviceId/:date', authenticateToken, requireRole('restricted'), async (req, res) => {
  const { deviceId, date } = req.params; // date = YYYY-MM-DD
  const r = await pool.query('SELECT * FROM device_bandwidth WHERE device_id=$1 AND day=$2', [deviceId, date]);
  res.json(r.rows[0] || { device_id: deviceId, day: date, bytes: 0 });
});

// ---------- Simple admin UI endpoints (optional) ----------
app.get('/api/admin/dashboard', authenticateToken, requireRole('restricted'), async (req, res) => {
  // basic dashboard summary
  const screens = await pool.query('SELECT id, device_id, name, status, last_seen FROM screens ORDER BY last_seen DESC LIMIT 100');
  const media = await pool.query('SELECT id, name, type, url FROM media ORDER BY id DESC LIMIT 100');
  res.json({ screens: screens.rows, media: media.rows });
});

// ---------- Scheduled tasks (example): daily aggregation ----------
cron.schedule('0 0 * * *', async () => {
  // daily task at midnight UTC: (for example) mark offline screens not seen in last 10 minutes
  try {
    const threshold = new Date(Date.now() - 10 * 60 * 1000);
    await pool.query('UPDATE screens SET status = $1 WHERE last_seen < $2', ['offline', threshold.toISOString()]);
    console.log('Daily maintenance task executed');
  } catch (e) {
    console.error('Cron error', e);
  }
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on port ${PORT}`);
});
