// index.js
const express = require('express');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { Pool } = require('pg');
const path = require('path');
const multer = require('multer');
const fs = require('fs');

const app = express();
const PORT = process.env.PORT || 5000;
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Database connection (Supabase/Dupabase provide a Postgres DATABASE_URL)
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  // If using SSL required by your provider, uncomment:
  // ssl: { rejectUnauthorized: false }
});

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// static public files
app.use(express.static(path.join(__dirname, 'public')));
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Ensure uploads folder exists
const uploadsDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir);

// Multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadsDir),
  filename: (req, file, cb) => {
    const ts = Date.now();
    const safe = file.originalname.replace(/\s+/g, '_');
    cb(null, `${ts}_${safe}`);
  }
});
const upload = multer({ storage });

// ---- AUTH ROUTES ----
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password } = req.body;
    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await pool.query(
      'INSERT INTO users (email, password_hash) VALUES ($1, $2) RETURNING id, email',
      [email, hashedPassword]
    );
    res.json({ message: 'User registered', userId: result.rows[0].id });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    const user = result.rows[0];
    if (!user || !(await bcrypt.compare(password, user.password_hash))) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const accessToken = jwt.sign({ sub: user.id, email: user.email }, JWT_SECRET, { expiresIn: '24h' });
    res.json({ accessToken, user: { id: user.id, email: user.email } });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// Simple middleware to protect admin routes
function authenticate(req, res, next) {
  const auth = req.headers.authorization;
  if (!auth) return res.status(401).json({ error: 'Missing auth' });
  const parts = auth.split(' ');
  if (parts.length !== 2) return res.status(401).json({ error: 'Invalid auth format' });
  const token = parts[1];
  try {
    const payload = jwt.verify(token, JWT_SECRET);
    req.user = payload;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// ---- SCREENS (devices) ----
app.get('/api/screens', async (req, res) => {
  const result = await pool.query('SELECT * FROM screens ORDER BY id');
  res.json(result.rows);
});

app.post('/api/screens', async (req, res) => {
  const { deviceId, name, location, status, resolution } = req.body;
  const result = await pool.query(
    'INSERT INTO screens (device_id, name, location, status, resolution, last_seen) VALUES ($1, $2, $3, $4, $5, now()) RETURNING *',
    [deviceId, name, location, status || 'offline', resolution]
  );
  res.status(201).json(result.rows[0]);
});

app.patch('/api/screens/:id', async (req, res) => {
  const { id } = req.params;
  const { name, location, status } = req.body;
  const result = await pool.query(
    'UPDATE screens SET name = COALESCE($1, name), location = COALESCE($2, location), status = COALESCE($3, status), last_seen = now() WHERE id = $4 RETURNING *',
    [name, location, status, id]
  );
  res.json(result.rows[0]);
});

app.delete('/api/screens/:id', async (req, res) => {
  await pool.query('DELETE FROM screens WHERE id = $1', [req.params.id]);
  res.json({ message: 'Screen deleted' });
});

// ---- MEDIA ----
app.get('/api/media', async (req, res) => {
  const result = await pool.query('SELECT * FROM media ORDER BY id');
  res.json(result.rows);
});

// Upload an asset (image/video) â€” admin only
app.post('/api/media/upload', authenticate, upload.single('file'), async (req, res) => {
  try {
    const file = req.file;
    const { name, duration } = req.body;
    if (!file) return res.status(400).json({ error: 'No file uploaded' });

    // determine type from mimetype
    const mime = file.mimetype || '';
    const type = mime.startsWith('video') ? 'video' : 'image';
    const url = `/uploads/${file.filename}`; // served statically

    const result = await pool.query(
      'INSERT INTO media (name, type, url, size, duration) VALUES ($1, $2, $3, $4, $5) RETURNING *',
      [name || file.originalname, type, url, file.size || 0, duration || null]
    );

    res.status(201).json(result.rows[0]);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Upload failed' });
  }
});

app.post('/api/media', authenticate, async (req, res) => {
  const { name, type, url, size, duration } = req.body;
  const result = await pool.query(
    'INSERT INTO media (name, type, url, size, duration) VALUES ($1, $2, $3, $4, $5) RETURNING *',
    [name, type, url, size || 0, duration || null]
  );
  res.status(201).json(result.rows[0]);
});

app.delete('/api/media/:id', authenticate, async (req, res) => {
  await pool.query('DELETE FROM media WHERE id = $1', [req.params.id]);
  res.json({ message: 'Media deleted' });
});

// ---- Playlists: assign media to screens ----
app.get('/api/playlists/:screenId', async (req, res) => {
  const { screenId } = req.params;
  const result = await pool.query(
    `SELECT p.id as playlist_id, p.position, p.duration_override, m.* 
     FROM playlists p
     JOIN media m ON m.id = p.media_id
     WHERE p.screen_id = $1
     ORDER BY p.position ASC`,
    [screenId]
  );
  res.json(result.rows);
});

app.post('/api/playlists', authenticate, async (req, res) => {
  // body: { screen_id, media_id, position, duration_override }
  const { screen_id, media_id, position, duration_override } = req.body;
  const result = await pool.query(
    'INSERT INTO playlists (screen_id, media_id, position, duration_override) VALUES ($1, $2, $3, $4) RETURNING *',
    [screen_id, media_id, position || 0, duration_override || null]
  );
  res.status(201).json(result.rows[0]);
});

app.delete('/api/playlists/:id', authenticate, async (req, res) => {
  await pool.query('DELETE FROM playlists WHERE id = $1', [req.params.id]);
  res.json({ message: 'Playlist entry deleted' });
});

// ---- Device registration + heartbeat & fetch playlist for device (Android client) ----

// Register device (Android app calls once on first boot)
app.post('/api/device/register', async (req, res) => {
  try {
    const { deviceId, name, resolution } = req.body;
    // upsert into screens table
    const existing = await pool.query('SELECT * FROM screens WHERE device_id = $1', [deviceId]);
    if (existing.rows.length > 0) {
      const row = existing.rows[0];
      await pool.query('UPDATE screens SET name = $1, resolution = $2, last_seen = now(), status = $3 WHERE device_id = $4', [name || row.name, resolution || row.resolution, 'online', deviceId]);
      return res.json({ message: 'Device updated', screen: row });
    } else {
      const r = await pool.query(
        'INSERT INTO screens (device_id, name, resolution, status, last_seen) VALUES ($1, $2, $3, $4, now()) RETURNING *',
        [deviceId, name || null, resolution || null, 'online']
      );
      return res.status(201).json({ message: 'Device registered', screen: r.rows[0] });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Device register failed' });
  }
});

// Heartbeat: device posts status JSON (memory, brightness, etc.)
app.post('/api/device/:deviceId/heartbeat', async (req, res) => {
  try {
    const { deviceId } = req.params;
    const { status } = req.body; // arbitrary JSON structure
    // find screen id
    const screen = await pool.query('SELECT * FROM screens WHERE device_id = $1', [deviceId]);
    if (!screen.rows[0]) return res.status(404).json({ error: 'Device not registered' });
    const screenId = screen.rows[0].id;
    await pool.query('INSERT INTO heartbeats (screen_id, status) VALUES ($1, $2)', [screenId, status || {}]);
    await pool.query('UPDATE screens SET last_seen = now(), status = $1 WHERE id = $2', [status?.online ? 'online' : 'online', screenId]);
    res.json({ message: 'Heartbeat recorded' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Heartbeat error' });
  }
});

// Android / Player fetching playlist by device id
app.get('/api/device/:deviceId/playlist', async (req, res) => {
  try {
    const { deviceId } = req.params;
    const screen = await pool.query('SELECT * FROM screens WHERE device_id = $1', [deviceId]);
    if (!screen.rows[0]) return res.status(404).json({ error: 'Device not found' });
    const screenId = screen.rows[0].id;

    const rows = await pool.query(
      `SELECT p.id as playlist_id, p.position, p.duration_override, m.id as media_id, m.name, m.type, m.url, m.duration as media_duration
       FROM playlists p
       JOIN media m ON m.id = p.media_id
       WHERE p.screen_id = $1
       ORDER BY p.position ASC`,
      [screenId]
    );

    // build playlist in client-friendly format
    const playlist = rows.rows.map(r => ({
      playlist_id: r.playlist_id,
      media_id: r.media_id,
      type: r.type,
      name: r.name,
      url: (r.url && r.url.startsWith('/uploads')) ? `${req.protocol}://${req.get('host')}${r.url}` : r.url,
      duration: r.duration_override || r.media_duration || null
    }));

    res.json({ deviceId, playlist });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Playlist fetch error' });
  }
});

// ---- Simple admin UI route (served statically) ----
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

// ---- API test route (used earlier but not required) ----
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`Server running on port ${PORT}`);
});
